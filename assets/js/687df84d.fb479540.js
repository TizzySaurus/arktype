"use strict";(self.webpackChunkredo_dev=self.webpackChunkredo_dev||[]).push([[6267],{8044:(e,n,r)=>{r.d(n,{Zo:()=>c,kt:()=>u});var t=r(9231);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=t.createContext({}),p=function(e){var n=t.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},c=function(e){var n=p(e.components);return t.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(r),u=o,f=m["".concat(l,".").concat(u)]||m[u]||d[u]||a;return r?t.createElement(f,i(i({ref:n},c),{},{components:r})):t.createElement(f,i({ref:n},c))}));function u(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},574:(e,n,r)=>{r.d(n,{g:()=>h});var t=r(5712),o=r(9231);const a=e=>{const n=i[e];return`import {populateDemo} from "./populateDemo"\n${n[0]}\npopulateDemo(${n[1]})`},i={model:['import {fetchUser, error, user} from "./model"',"{data: fetchUser(), error, definition: user.definition}"],space:['import {readPackageData, getValidatedPackageData, redo} from "./space"\nlet error\ntry{\n    getValidatedPackageData()\n}catch(e){\n    error = e\n}',"{data: readPackageData(), definition: redo.inputs.dictionary, error }"],constraints:['import {employee, fetchEmployee, error} from "./constraints"',"{data: fetchEmployee(), definition: employee.definition, error }"],declaration:['import {mySpace, fetchGroupData, error } from "./declaration"',"{data: fetchGroupData(), definition: mySpace.inputs.dictionary, error}"]};var s=r(9672);const l={"index.html":'<head>\n    <link href="http://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet" />\n</head>\n<div id="demo">\n    <div id="input">\n        <div class="section">\n            <h3>Definition</h3>\n            <div class="card">\n                <pre><code id="definition"></code></pre>\n            </div>\n        </div>\n        <div class="section">\n            <h3>Data</h3>\n            <div class="card">\n                <pre id="data"></pre>\n            </div>\n        </div>\n    </div>\n    <div class="section">\n        <h3>Result</h3>\n        <div class="card">\n            <p id="result"></p>\n        </div>\n    </div>\n</div>\n',"demo.css":'body {\n    font-family: "Cascadia Code", sans-serif;\n    background-color: hsl(220 18% 10%);\n}\n\n#demo {\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    margin: -8px;\n    padding: 8px;\n}\n\n#input {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    gap: 8px;\n}\n\n.section {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    gap: 8px;\n}\n\n.card {\n    padding: 8px;\n    background-color: rgb(18, 18, 18);\n    color: rgb(255, 255, 255);\n    /* transition: box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms; */\n    border-radius: 4px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 2px 1px -1px,\n        rgba(0, 0, 0, 0.14) 0px 1px 1px 0px, rgba(0, 0, 0, 0.12) 0px 1px 3px 0px;\n    background-image: linear-gradient(\n        rgba(255, 255, 255, 0.05),\n        rgba(255, 255, 255, 0.05)\n    );\n    height: 100%;\n}\n\np {\n    white-space: pre-wrap;\n}\n\npre {\n    white-space: pre-wrap;\n}\n\nh3 {\n    margin: 0px;\n    color: #fff;\n}\n\n.key {\n    color: #264bcf;\n}\n.val {\n    color: #ffc40c;\n}\n',"populateDemo.ts":'import "./demo.css";\nexport const populateDemo = ({ data, definition, error }) => {\n  const defElement = document.querySelector("#definition");\n  defElement.textContent = JSON.stringify(definition, null, 2);\n  defElement.innerHTML = recolor(defElement.innerHTML);\n  const dataElement = document.querySelector("#data");\n  dataElement.textContent = JSON.stringify(data, null, 2);\n  dataElement.innerHTML = recolor(dataElement.innerHTML);\n  document.querySelector("#result").textContent = error != null ? error : "Looks good!";\n};\nfunction recolor(input) {\n  const lines = input.split("\\n");\n  const fixedInput = [];\n  for (const line of lines) {\n    if (line.includes(":")) {\n      const parts = line.split(":");\n      fixedInput.push(`${buildKey(parts[0])}: ${buildVal(parts[1])}`);\n    } else {\n      fixedInput.push(line);\n    }\n  }\n  return fixedInput.join("\\n");\n}\nfunction buildKey(key) {\n  return `<span class=\'key\'>${key}</span>`;\n}\nfunction buildVal(val) {\n  const formatted = val.trim();\n  if (formatted.at(-1) === ",") {\n    return `<span class=\'val\'>${formatted.replace(",", "")}</span>,`;\n  } else if (formatted.at(-1) === "{") {\n    return "{";\n  }\n  return `<span class=\'val\'>${formatted}</span>`;\n}\n',"tsconfig.json":JSON.stringify({compilerOptions:{module:"esnext",target:"esnext",strict:!0}},null,4)},p={user:'import { define } from "./declaration"\n\nexport const userDef = define.user({\n    name: "string",\n    bestFriend: "user?",\n    groups: "group[]"\n})\n',group:'import { define } from "./declaration"\n\nexport const groupDef = define.group({\n    title: "string",\n    members: "user[]"\n})\n'},c={model:'import { model } from "@re-/model"\n\n// Models look just like types...\nexport const user = model({\n    age: "number",\n    browser: "\'chrome\'|\'firefox\'|\'other\'|null",\n    name: {\n        first: "string",\n        middle: "string?",\n        last: "string"\n    }\n})\n\n// And can be used just like types...\nexport type User = typeof user.type\nexport type EquivalentType = {\n    age: number\n    browser: "chrome" | "firefox" | "other" | null\n    name: {\n        first: string\n        middle?: string\n        last: string\n    }\n}\n\n// But while types are confined to your IDE...\nexport const fetchUser = () => {\n    return {\n        name: {\n            first: "Dan",\n            last: "Ambramov"\n        },\n        age: 29,\n        browser: "Internet Explorer" // R.I.P.\n    }\n}\n\n// Models can validate your data anytime, anywhere, with the same clarity and precision you expect from TypeScript.\nexport const { error, data } = user.validate(fetchUser())\n\nif (error) {\n    // "At path browser, \'Internet Explorer\' is not assignable to any of \'chrome\'|\'firefox\'|\'other\'|null."\n    console.log(error.message)\n}\n\n// Try changing "user" or "fetchUser" and see what happens!\n',space:'import { space } from "@re-/model"\n\n// Spaces are collections of models that can reference each other.\nexport const redo = space({\n    package: {\n        name: "string",\n        version: "string",\n        dependencies: "package[]",\n        contributors: "contributor[]"\n    },\n    contributor: {\n        name: "string",\n        isInternal: "boolean",\n        packages: "package[]"\n    }\n})\n\n// Recursive and cyclic types are inferred to arbitrary depth.\nexport type Package = typeof redo.types.package\n\nexport const readPackageData = () => {\n    return {\n        name: "@re-/model",\n        version: "latest",\n        dependencies: [\n            {\n                name: "@re-/tools",\n                version: 2.2,\n                dependencies: []\n            }\n        ],\n        contributors: [\n            {\n                name: "David Blass",\n                isInternal: true\n            }\n        ]\n    }\n}\n\nexport const getValidatedPackageData = () => {\n    const packageDataFromFile = readPackageData()\n    // Throws: `Error: Encountered errors at the following paths:\n    //    dependencies/0/version: 2.2 is not assignable to string.\n    //    dependencies/0/contributors: Required value of type contributor[] was missing.\n    //    contributors/0/packages: Required value of type package[] was missing.`\n    const validatedPackageData = redo.models.package.assert(packageDataFromFile)\n    return validatedPackageData\n}\n',constraints:"import { model } from \"@re-/model\"\n\nexport const employee = model({\n    // Not a fan of regex? Don't worry, 'email' is a builtin type :)\n    email: `/[a-z]*@redo.dev/`,\n    about: {\n        // Single or double bound numeric types\n        age: \"18<=integer<125\",\n        // Or string lengths\n        bio: \"string<=80\"\n    }\n})\n\n// Subtypes like 'email' and 'integer' become 'string' and 'number'\ntype Employee = typeof employee.type\n\nexport const fetchEmployee = () => {\n    return {\n        email: \"david@redo.biz\",\n        about: {\n            age: 17,\n            bio: \"I am very interesting.\".repeat(5)\n        }\n    }\n}\n// The error messages are so nice you might be tempted to break your code more often ;)\nexport const { error } = employee.validate(fetchEmployee())\n\n// Output: \"Encountered errors at the following paths:\n// {\n//   email: ''david@redo.biz' is not assignable to /[a-z]*@redo.dev/.',\n//   about/age: '17 was less than 18.',\n//   about/bio: ''I am very interesting.I am very interesting.I am... was greater than 80 characters.'\n// }\"\nconsole.log(error.message ?? \"Flawless. Obviously.\")\n",declaration:'import { declare } from "@re-/model"\n\n// Declare the models you will define\nexport const { define, compile } = declare("user", "group")\n\nimport { groupDef } from "./group"\nimport { userDef } from "./user"\n\n// Creates your space (or tells you which definition you forgot to include)\nexport const mySpace = compile({ ...userDef, ...groupDef })\n\n// Mouse over "Group" to see the inferred type...\nexport type Group = typeof mySpace.models\n\nexport const fetchGroupData = () => {\n    return {\n        title: "Type Enjoyers",\n        members: [\n            {\n                name: "Devin Aldai",\n                grapes: []\n            }\n        ]\n    }\n}\n\n// Try changing the definitions in "group.ts"/"user.ts" or the data in "fetchGroupData"!\nexport const { error } = mySpace.models.group.validate(fetchGroupData())\n'};var d=Object.defineProperty,m=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,f=Object.prototype.propertyIsEnumerable,g=(e,n,r)=>n in e?d(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,y=(e,n)=>{for(var r in n||(n={}))u.call(n,r)&&g(e,r,n[r]);if(m)for(var r of m(n))f.call(n,r)&&g(e,r,n[r]);return e};const b=e=>{const n={};for(const r of e)n[`${r}.ts`]=p[r];return n},h=({embedId:e,addonFiles:n})=>((0,o.useEffect)((()=>{(({files:e,title:n,description:r,embedId:t})=>{s.Z.embedProject("demo",{files:e,title:n,description:r,template:"typescript",dependencies:{"@re-/tools":"latest","@re-/model":"latest"}},{clickToLoad:!1,view:"default",height:"100%",width:"100%",openFile:`${t}.ts`})})({files:y(y({[`${e}.ts`]:c[e],"index.ts":a(e)},l),b(null!=n?n:[])),title:`${e}`,description:`Demo for ${e}`,embedId:e})}),[]),o.createElement(t.Z,{style:{width:"100%",height:"660px",border:0,marginLeft:-8,marginRight:-8,padding:16,overflow:"hidden",borderRadius:"8px"}},o.createElement("div",{id:"demo"})))},3284:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>y,contentTitle:()=>f,default:()=>v,frontMatter:()=>u,metadata:()=>g,toc:()=>b});var t=r(8044),o=r(574),a=Object.defineProperty,i=Object.defineProperties,s=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,n,r)=>n in e?a(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,m=(e,n)=>{for(var r in n||(n={}))p.call(n,r)&&d(e,r,n[r]);if(l)for(var r of l(n))c.call(n,r)&&d(e,r,n[r]);return e};const u={hide_table_of_contents:!0},f="Spaces",g={unversionedId:"spaces",id:"version-2.0.5-alpha/spaces",title:"Spaces",description:"Working with types that refer to one another or themselves? So can your models!",source:"@site/model_versioned_docs/version-2.0.5-alpha/spaces.mdx",sourceDirName:".",slug:"/spaces",permalink:"/model/spaces",draft:!1,tags:[],version:"2.0.5-alpha",frontMatter:{hide_table_of_contents:!0},sidebar:"sidebar",previous:{title:"Model",permalink:"/model/"},next:{title:"Declarations",permalink:"/model/declarations"}},y={},b=[],h={toc:b};function v(e){var n,r=e,{components:a}=r,d=((e,n)=>{var r={};for(var t in e)p.call(e,t)&&n.indexOf(t)<0&&(r[t]=e[t]);if(null!=e&&l)for(var t of l(e))n.indexOf(t)<0&&c.call(e,t)&&(r[t]=e[t]);return r})(r,["components"]);return(0,t.kt)("wrapper",(n=m(m({},h),d),i(n,s({components:a,mdxType:"MDXLayout"}))),(0,t.kt)("h1",m({},{id:"spaces"}),"Spaces"),(0,t.kt)("p",null,"Working with types that refer to one another or themselves? So can your models!"),(0,t.kt)("p",null,"Just compile a ",(0,t.kt)("strong",{parentName:"p"},"space"),"."),(0,t.kt)("div",{style:{width:"100%",height:"730px",border:0,marginLeft:-8,marginRight:-8,padding:16,overflow:"hidden",borderRadius:8}},(0,t.kt)(o.g,{embedId:"space",mdxType:"StackBlitzDemo"})))}v.isMDXComponent=!0}}]);